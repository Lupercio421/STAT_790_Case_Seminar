---
title: "ACS data"
author: "Daniel L."
date: "4/5/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(readxl)
```

# 2019 ACS data

```{r}
demo_2019_acs5yr_cdta <- read_excel("external_datasets/demo_2019_acs5yr_cdta.xlsx", 
                                    sheet = "DemData")
```

```{r}
#glimpse(demo_2019_acs5yr_cdta)
```


```{r deleting cd's of airports and parks}
#demo_2019_acs5yr_cdta <- 
#demo_2019_acs5yr_cdta %>% filter(GeoID != c("BX26", "BX27"),GeoID != "BX28", GeoID != ("SI95"))

demo_2019_acs5yr_cdta <- demo_2019_acs5yr_cdta %>% filter(!GeoID %in% 
                                   c("BK55","BK56", "BX26", "BX27", "BX28", "MN64", "QN80", "QN81", "QN82", "QN83", "QN84", "SI95"))

#using stringr's str_sub on GeoID to create a separate communitydistrict column
str_length(demo_2019_acs5yr_cdta$GeoID)
# all these GeoID's have length 4, so we can select the 3rd and 4th letter in the character as our communitydistrict
# demo_2019_acs5yr_cdta %>% mutate(as.integer(CD = case_when(starts_with(GeoID, 0))))
as.integer(str_sub(demo_2019_acs5yr_cdta$GeoID, 3,4))
demo_2019_acs5yr_cdta <- demo_2019_acs5yr_cdta %>% mutate(communitydistrict = as.integer(str_sub(GeoID, 3,4)))


demo_2019_acs5yr_cdta %>% select(ends_with("E"))
demo_2019_acs5yr_cdta %>% select(starts_with("P"))
#demo_2019_acs5yr_cdta %>% filter(names(.) %in% starts_with("Pop"))
```

help from this [article](https://statisticsglobe.com/r-extract-first-or-last-n-characters-from-string)
and dpylr help from this [site](https://dplyr.tidyverse.org/reference/select.html)

```{r}
demo_2019_acs5yr_cdta %>% select(Borough,communitydistrict,ends_with("E"))
```

```{r estimate totals by borough}
total <- list(
  total = ~sum(.x, na.rm = TRUE)
)

demo_2019_acs5yr_cdta %>%
  group_by(Borough) %>% 
  select(Borough,
           ends_with("E",
                     ignore.case = FALSE)) %>%
  summarise(across(where(is.numeric), total, .names = "{.col}_{.fn}"))

bx_2019_demo_total_estimates <- demo_2019_acs5yr_cdta %>%
  filter(Borough == "Bronx") %>% 
  group_by(Borough) %>% 
  select(Borough,
           ends_with("E",
                     ignore.case = FALSE)) %>%
  summarise(across(where(is.numeric), total, .names = "{.col}_{.fn}"))
```


## Columns that end with "E" are estimates of the populations. They are integers. Also decide if it is worth grabbing the total population estimates of each individual country, or total population estimates of each race/origin.

## 2019 Census Bureau ACS Economic Profile

```{r econ data}
econ_2019_acs5yr_cdta <- read_excel("external_datasets/econ_2019_acs5yr_cdta.xlsx", 
    sheet = "EconData")

econ_2019_acs5yr_cdta <- econ_2019_acs5yr_cdta %>% filter(!GeoID %in% 
                                   c("BK55","BK56", "BX26", "BX27", "BX28", "MN64", "QN80", "QN81", "QN82", "QN83", "QN84", "SI95"))

econ_2019_acs5yr_cdta <- econ_2019_acs5yr_cdta %>% mutate(communitydistrict = as.integer(str_sub(GeoID, 3,4)))
```

```{r}
econ_2019_acs5yr_cdta %>% select(ends_with("E"))
```

Attempting to get the total estimates, by borough

```{r cd totals}
#   mutate(total_waste = select(.,4:6) %>% rowSums(na.rm = TRUE))
econ_2019_acs5yr_cdta %>% 
  group_by(Borough) %>% 
  select(Borough,
         ends_with("E",
                   ignore.case = FALSE)) 
```

Help from [blog](https://www.tidyverse.org/blog/2020/04/dplyr-1-0-0-colwise/) by Hadley Wickham

```{r}
econ_2019_acs5yr_cdta %>% 
  group_by(Borough) %>% 
  select(Borough,
         ends_with("E",
                   ignore.case = FALSE)) %>% 
  summarise(across(1:131, sum))

econ_2019_acs5yr_cdta %>% 
  group_by(Borough) %>% 
  select(Borough,
         ends_with("E",
                   ignore.case = FALSE)) %>% 
  summarise(across(where(is.numeric), sum))

# econ_2019_acs5yr_cdta %>% 
#   group_by(Borough) %>% 
#   select(Borough,
#          ends_with("E",
#                    ignore.case = FALSE)) %>% 
#   transmute(total = summarise(across(where(is.numeric), sum)))
# 
# 
# econ_2019_acs5yr_cdta %>% 
#   group_by(Borough) %>% 
#   select(Borough,
#          ends_with("E",
#                    ignore.case = FALSE)) %>%
#   transmute(rowwise(.), total = summarise(across(where(is.numeric), sum)))
# 
# econ_2019_acs5yr_cdta %>% 
#   group_by(Borough) %>% 
#   select(Borough,
#          ends_with("E",
#                    ignore.case = FALSE)) %>% 
#   summarise(across(where(is.numeric), sum), n = n())
```

And more column-wise operations help with this [article](https://dplyr.tidyverse.org/dev/articles/colwise.html#multiple-functions)

```{r}
# min_max <- list(
#   min = ~min(.x, na.rm = TRUE), 
#   max = ~max(.x, na.rm = TRUE)
# )

total <- list(
  total = ~sum(.x, na.rm = TRUE)
)

# econ_2019_acs5yr_cdta %>% 
#   group_by(Borough) %>% 
#   select(Borough,
#          ends_with("E",
#                    ignore.case = FALSE)) %>%
#   summarise(across(where(is.numeric), min_max))

econ_2019_acs5yr_cdta %>% 
  group_by(Borough) %>% 
  select(Borough,
         ends_with("E",
                   ignore.case = FALSE)) %>%
  summarise(across(where(is.numeric), total, .names = "{.col}_{.fn}"))

bx_2019_econ_total_estimates <- econ_2019_acs5yr_cdta %>% 
  filter(Borough == "Bronx") %>% 
  group_by(Borough) %>% 
  select(Borough,
         ends_with("E",
                   ignore.case = FALSE)) %>%
  summarise(across(where(is.numeric), total, .names = "{.col}_{.fn}"))

```

This method also works, as we will be returned a tibble of 655x3. Where instead of 132 columns per borough, we have 132 total values per borough

```{r pivot_longer}
# econ_2019_acs5yr_cdta %>%  
#   select(Borough,
#          ends_with("E",
#                    ignore.case = FALSE)) %>% 
#   pivot_longer(
#     cols = -Borough, # all columns except Borough should be made into one column
#     names_to = "metric",
#     values_to = "value") %>%
#   group_by(Borough, metric) %>%
#   summarise(total = sum(value)) %>% # sum up by borough and metric
#   ungroup() 

# econ_2019_acs5yr_cdta %>%  
#   select(Borough,
#          ends_with("E",
#                    ignore.case = FALSE)) %>% 
#   pivot_wider(
#     id_cols = -Borough, # all columns except Borough should be made into one column
#     names_to = "metric",
#     values_to = "value") %>%
#   group_by(Borough, metric) %>%
#   summarise(total = sum(value)) %>% # sum up by borough and metric
#   ungroup()
```

## Joining 2019 BX timeseries

```{r}
load("C:/Users/Daniel/Desktop/R/STAT_790/STAT_790_Case_Seminar/BX_ts.RData")
load("C:\\Users\\Daniel\\Desktop\\R\\STAT_790\\STAT_790_Case_Seminar\\data_prep.Rdata")
```

### I now understand that the Economic and Demographic data is not divided into monthly values. Rather, they are estimates of an entire year.

There is a chance we can join the demographic or economic data onto the community districts for the original training data frame. But again, we are given total estimates for the year. Data separated by community districts began for the year 2007. There are years where estimates are provided for two community districts in the Bronx and Manhattan. And there isn't always data for the year. Rather there is data for 3, 4, even 5 year estimates. Making this complicated to state estimates for a strict 1 year period. 

On top of this, they are count values. Which could lead to the possibility of creating a count regression. Which would stray away from the goal of this project. 
